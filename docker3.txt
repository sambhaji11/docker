Docker Volumes:
Volumes are the preferred mechanism for persisting data generated by and used by Docker containers
- A volume allows data to persist, even when a container is deleted. Volumes are also a convenient way to share data between the host and the container.

docker volume  //get information
docker volume create
docker volume ls
docker volume inspect
docker volume rm
docker volume prune

Use of Volumes
===================
Decoupling container from storage
Share volume (storage/data) among different containers
Attach volume to container
On deleting container volume does not delete

Examples:
Step 1 — Creating an Independent Volume

-------------------
---> make a data volume called data:
docker volume create mydata

--->list of all the volumes created and their driver
docker volume ls

--->Get details of the volume
docker volume inspect mydata

--->removing volumes
docker volume rm mydata

-------------

Commands
docker run --name MyJenkins1 -v myvol1:/var/jenkins_home -p 8080:8080 -p 50000:50000  -d jenkins
docker logs MyJenkin1

42bb97839eb241d2b1c7e1934094e6a7
docker run --name MyJenkins2 -v myvol1:/var/jenkins_home -p 9090:8080 -p 60000:50000 jenkins

Note : only run the first command in detached mode
When you run the Jenkins second instance it will not generate the admin password . It will take the same password for the first one as it is stored and data is shared between volumes.
---------------------------------------------------------------------====================================================================
Docker compose

It is a utility tool for defining & running multi-container docker applications
use yaml files to configure application services (docker-compose.yml)
can start all services with a single command : docker compose up
can stop all services with a single command : docker compose down
can scale up selected services when required


Step 1 : install docker compose
   (already installed on windows and mac with docker)
   docker-compose -v

   2 Ways

   1.  https://github.com/docker/compose/rel...

   2. Using PIP
    pip install -U docker-compose

Step 2 : Create docker compose file at any location on your system
   docker-compose.yml

version: '3'
services:
  web:
    image: nginx
  database:
    image: redis


Step 3 : Check the validity of file by command
    docker-compose config

docker network ls
there is no "root_default" now execute the below it should create this network

Step 4 : Run docker-compose.yml file by command
   docker-compose up -d
$docker ps
$docker inspect network root_default

so docker-compose internally creates a custom bridge network.

Steps 5 : Bring down application by command
 $  docker-compose down
 $docker inspect network root-default

TIPS
How to scale services

scale
docker-compose up -d --scale database=4
---------------------------------------------
Example 2:
docker-compose.yml
=====================
version: '3.3'

services:
   db:
     image: mysql:5.7
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: somewordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress
   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - "8000:80"
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress
       WORDPRESS_DB_NAME: wordpress
volumes:
    db_data: {}

 
docker-compose up -d

=====================================================================
===>Why docker Networking:
Docker takes care of the networking aspects so that the containers can communicate with other containers and also with the Docker Host.

Manage networks
================
Commands:
  connect     Connect a container to a network
  create      Create a network
  disconnect  Disconnect a container from a network
  inspect     Display detailed information on one or more networks
  ls          List networks
  prune       Remove all unused networks
  rm          Remove one or more networks

docker network ls  ---> from docker envt like docker playground
sudo docker network ls  ---> from a machine like windows toolbox
docker network inspect networkname  --->get detailed info of the network
--------------------------------------------------------------------
docker run --name centos-1 -it centos bash
docker run --name centos-2 -it centos bash

--problem with the bridge network
bridge network will assign IPS to containers, which will be dynamic. So if we have 100 containers each time the containers are started they will have different Ips.Which is not prefereed so we want to communicate using the name. Therefore we can go for custom bridge network


docker network create myNetwork
or is equal to
docker network create myNetwork -d bridge

docker run --name mycentos1 --network myNetwork -it centos bash
docker run --name mycentos2 --network myNetwork -it centos bash

$docker network inspect mynetwork
$docker start centos-3 centos-4

$ docker exec -it centos-3 bash
[root@a1e11e235199 /]# ping centos-4
PING centos-4 (172.19.0.2) 56(84) byt

Note : Now we are able tocommunicate with the name of the container.


-->Make sure that containers are in started state
docker network connect mynetwork centos-1
docker network connect mynetwork centos-2

-->containers in no network
$ docker run --name centos-5 --network none -it centos bash
$docker inspect network none
$docker start centos-5
$docker inspect network none
--> there is no ip assigned

--->Removing the network
docker network rm mynetwork
Note: you cannot remove the network if there are active containers. so lets remove the containers from the network.
docker network disconnect mynetwork centos-1
docker network rm mynetwork
-----------------------------------------------------------------------------------
--to expose any containers service to outside world we need to do the port mapping or port forwardisation
docker run --name a-nginx -p 1111:80 -d nginx
docker run --name b-nginx -p 2222:80 -d nginx
docker run --name c-nginx -p 3333:80 -d nginx
docker run --name d-nginx -p 4444:80 -d nginx

drawback :We also cannot assign the same port to another container
Here the host network comes into picture.

--Now lets create a container in the host network
docker run --name f-nginx --network host -d nginx

In the above way there is no need of doing port forwardisation. Even if we try to do any port f , it will discard it.

$ docker run --name g-nginx --network host -p 1111:80  -d nginx
WARNING: Published ports are discarded when using host network mode
51cd692352057811c15efa1da7896cf2cb1cfe0b34957899c41c525e133df82c
[node1] (local) root@192.168.0.33 ~
$

$docker ps -a
$docker logs g-nginx
 ------------------------------------------------------------------------------------------
---->What is the difference between bridge and host networking

If you use the host network driver for a container, that container’s network stack is not isolated from the Docker host. For instance, if you run a container which binds to port 80 and you use host networking, the container’s application will be available on port 80 on the host’s IP address.

Host networking completely disables Docker's network isolation. It means containers see and use exactly the same network interfaces the host has available, without an intermediate NAT layer.
With bridge networking, you need the docker run -p option to make specific ports visible outside of Docker. As an operator you can remap ports, bind to specific interfaces on a multi-homed system, or simply decline to make a service visible to other hosts at all. 

Ingress and Overlay Network

overlay network:
--The Overlay Network driver in Docker provides the ability to network containers across multiple Docker hosts in a cluster. 
--The overlay network driver creates a distributed network among multiple Docker daemon hosts. This network sits on top of (overlays) the host-specific networks, allowing containers connected to it (including swarm service containers) to communicate securely when encryption is enabled.
